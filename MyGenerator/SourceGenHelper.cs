using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace MyGenerator;

public static class SourceGenHelper
{
    private const string Header = @"//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by the MyGenerator source generator
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

#nullable enable";

    public const string Attribute = Header + @"
namespace MyGenerator.Attributes;

[AttributeUsage(AttributeTargets.Class)]
[System.Diagnostics.Conditional(""Sample"")]
    public class HelloExtensionAttribute : Attribute
    {
    }";

    public static string GeneratePartialClass(ITypeSymbol typeSymbol)
    {
        var className = typeSymbol.Name;
        var accessModifier = typeSymbol.DeclaredAccessibility.ToString().ToLower();
        var namespaceName = typeSymbol.ContainingNamespace.ToDisplayString();
        //var source = Header + $@"

        var sb = new StringBuilder();
        sb.AppendLine(Header);
        //var code = classDeclarationSyntax.NormalizeWhitespace().ToFullString();
        //var accessModifier = typeSymbol..FirstOrDefault(m => m.IsKind(SyntaxKind.PublicKeyword) || m.IsKind(SyntaxKind.InternalKeyword));
        sb.AppendLine("using HelloLib;");
        sb.AppendLine($"namespace {namespaceName};");
        sb.AppendLine($"    {accessModifier} partial class {className}");
        sb.AppendLine("    {");
        sb.AppendLine("        public string SayHelloWithNameWrapper(string name)");
        sb.AppendLine("        {");
        sb.AppendLine("return new Hello().SayHello(name);");
        sb.AppendLine("        }");
        sb.AppendLine("    }");

        return sb.ToString();
    }

    // determine the namespace the class/enum/struct is declared in, if any
    static string GetNamespace(BaseTypeDeclarationSyntax syntax)
    {
        // Code inspired from https://github.com/dotnet/runtime/blob/25c675ff78e0446fe596cea25c7e3969b0936a33/src/libraries/Microsoft.Extensions.Logging.Abstractions/gen/LoggerMessageGenerator.Parser.cs#L438

        // BaseDeclarationSyntax works for Class, Record and Enum  too, as they are subclasses of BaseTypeDeclarationSyntax
        if (syntax == null) throw new ArgumentNullException(nameof(syntax));

        // If we don't have a namespace at all we'll return an empty string
        // This accounts for the "default namespace" case
        var nameSpace = string.Empty;

        // Get the containing syntax node for the type declaration
        // (could be a nested type, for example)
        var potentialNamespaceParent = syntax.Parent;

        // Keep moving "out" of nested classes etc until we get to a namespace
        // or until we run out of parents
        while (potentialNamespaceParent != null &&
               potentialNamespaceParent is not NamespaceDeclarationSyntax
               && potentialNamespaceParent is not FileScopedNamespaceDeclarationSyntax)
        {
            potentialNamespaceParent = potentialNamespaceParent.Parent;
        }

        // Build up the final namespace by looping until we no longer have a namespace declaration
        if (potentialNamespaceParent is BaseNamespaceDeclarationSyntax namespaceParent)
        {
            // We have a namespace. Use that as the type
            nameSpace = namespaceParent.Name.ToString();

            // Keep moving "out" of the namespace declarations until we 
            // run out of nested namespace declarations
            while (true)
            {
                if (namespaceParent.Parent is not NamespaceDeclarationSyntax parent)
                {
                    break;
                }

                // Add the outer namespace as a prefix to the final namespace
                nameSpace = $"{namespaceParent.Name}.{nameSpace}";
                namespaceParent = parent;
            }
        }

        // return the final namespace
        return nameSpace;
    }

    public static string GeneratePartialClass2(ClassDeclarationSyntax classDeclarationSyntax)
    {
        var className = classDeclarationSyntax.Identifier.Text;
        var accessModifier = classDeclarationSyntax.Modifiers.FirstOrDefault(m =>
            m.IsKind(SyntaxKind.PublicKeyword) || m.IsKind(SyntaxKind.InternalKeyword));
        var namespaceName = GetNamespace(classDeclarationSyntax);
        //var source = Header + $@"

        var sb = new StringBuilder();
        sb.AppendLine(Header);
        //var code = classDeclarationSyntax.NormalizeWhitespace().ToFullString();
        //var accessModifier = typeSymbol..FirstOrDefault(m => m.IsKind(SyntaxKind.PublicKeyword) || m.IsKind(SyntaxKind.InternalKeyword));
        sb.AppendLine("using HelloLib;");
        sb.AppendLine($"namespace {namespaceName};");
        sb.AppendLine($"    {accessModifier} partial class {className}");
        sb.AppendLine("    {");
        sb.AppendLine("        public string SayHelloWithNameWrapper(string name)");
        sb.AppendLine("        {");
        sb.AppendLine("return new Hello().SayHello(name);");
        sb.AppendLine("        }");
        sb.AppendLine("    }");

        return sb.ToString();
    }

    public static string GenerateDuplicateClass(string className, string namespaceName,
        ClassDeclarationSyntax? classDeclarationSyntax, string accessModifier)
    {
        var sb = new StringBuilder();
        sb.AppendLine(Header);
        sb.AppendLine($"namespace {namespaceName};");
        classDeclarationSyntax = classDeclarationSyntax.RemoveNodes(classDeclarationSyntax.AttributeLists, SyntaxRemoveOptions.KeepNoTrivia);
        var code = classDeclarationSyntax.NormalizeWhitespace()?.ToFullString();
        
        var existingClassName = classDeclarationSyntax.Identifier.Text;
        code = code.Replace(existingClassName, className);
        var existingAccessModifier = classDeclarationSyntax.Modifiers.FirstOrDefault(m =>
            m.IsKind(SyntaxKind.PublicKeyword) || m.IsKind(SyntaxKind.InternalKeyword));
        code = code.Replace(existingAccessModifier.ToString(), accessModifier);
        sb.AppendLine(code);
        return sb.ToString();
    }
}